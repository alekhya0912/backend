package paymentinitiationbackend.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import paymentinitiationbackend.dto.ApprovalBatchDto;
import paymentinitiationbackend.dto.ApprovalRequestDto;
import paymentinitiationbackend.dto.ApprovalStatisticsDto;
import paymentinitiationbackend.model.Approval;
import paymentinitiationbackend.model.BankAccount;
import paymentinitiationbackend.model.Batch;
import paymentinitiationbackend.model.Employee;
import paymentinitiationbackend.model.User;
import paymentinitiationbackend.repository.ApprovalRepository;
import paymentinitiationbackend.repository.BankAccountRepository;
import paymentinitiationbackend.repository.BatchRepository;
import paymentinitiationbackend.repository.EmployeeRepository;
import paymentinitiationbackend.repository.UserRepository;
import paymentinitiationbackend.service.ApprovalService;
import paymentinitiationbackend.config.JwtTokenUtil;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.math.BigDecimal;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

@RestController
@RequestMapping("/api/approvals")
@Tag(name = "Approval Management", description = "APIs for managing payroll batch approvals")
public class ApprovalController {

    private final ApprovalService approvalService;
    private final BatchRepository batchRepository;
    private final EmployeeRepository employeeRepository;
    private final BankAccountRepository bankAccountRepository;
    private final UserRepository userRepository;
    private final ApprovalRepository approvalRepository;
    private final JwtTokenUtil jwtTokenUtil;
    private final PasswordEncoder passwordEncoder;

    @Autowired
    public ApprovalController(ApprovalService approvalService,
                              BatchRepository batchRepository,
                              EmployeeRepository employeeRepository,
                              BankAccountRepository bankAccountRepository,
                              UserRepository userRepository,
                              ApprovalRepository approvalRepository,
                              JwtTokenUtil jwtTokenUtil,
                              PasswordEncoder passwordEncoder) {
        this.approvalService = approvalService;
        this.batchRepository = batchRepository;
        this.employeeRepository = employeeRepository;
        this.bankAccountRepository=bankAccountRepository;
        this.userRepository = userRepository;
        this.approvalRepository = approvalRepository;
        this.jwtTokenUtil = jwtTokenUtil;
        this.passwordEncoder = passwordEncoder;
    }

    @GetMapping("/pending")
    @Operation(summary = "Get pending batches", description = "Retrieve all batches that are pending approval")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Successfully retrieved pending batches",
                    content = @Content(schema = @Schema(implementation = ApprovalBatchDto.class))),
            @ApiResponse(responseCode = "500", description = "Internal server error")
    })
    public ResponseEntity<List<ApprovalBatchDto>> getPendingBatches() {
        try {
            List<Batch> batches = batchRepository.findAll();
            List<ApprovalBatchDto> pending = batches.stream()
                    .filter(b -> b.getPaymentStatus() != null && b.getPaymentStatus().equalsIgnoreCase("Pending"))
                    .filter(b -> b.getDebitAccount() != null && !b.getDebitAccount().trim().isEmpty())
                    .filter(b -> b.getCurrency() != null && !b.getCurrency().trim().isEmpty())
                    .map(this::mapBatchToApprovalDto)
                    .toList();
            return ResponseEntity.ok(pending);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @GetMapping("/reviewed")
    @Operation(summary = "Get reviewed batches", description = "Retrieve all batches that have been approved or rejected")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Successfully retrieved reviewed batches",
                    content = @Content(schema = @Schema(implementation = ApprovalBatchDto.class))),
            @ApiResponse(responseCode = "500", description = "Internal server error")
    })
    public ResponseEntity<List<ApprovalBatchDto>> getReviewedBatches() {
        try {
            List<Batch> batches = batchRepository.findAll();
            System.out.println("Total batches found: " + batches.size());
            // Filter for approved or rejected batches
            List<ApprovalBatchDto> reviewed = batches.stream()
                    .filter(b -> {
                        String status = b.getPaymentStatus();
                        System.out.println("Batch ID: " + b.getId() + ", Status: " + status);
                        boolean isReviewed = status != null && (status.equalsIgnoreCase("approved") || status.equalsIgnoreCase("rejected"));
                        if (isReviewed) {
                            System.out.println("Batch " + b.getId() + " is reviewed (status: " + status + ")");
                        }
                        return isReviewed;
                    })
                    .map(batch -> {
                        try {
                            return mapBatchToApprovalDto(batch);
                        } catch (Exception e) {
                            System.err.println("Error mapping batch " + batch.getId() + ": " + e.getMessage());
                            e.printStackTrace();
                            return null;
                        }
                    })
                    .filter(java.util.Objects::nonNull)
                    .toList();
            System.out.println("Reviewed batches count: " + reviewed.size());
            return ResponseEntity.ok(reviewed);
        } catch (Exception e) {
            System.err.println("Error in getReviewedBatches: " + e.getMessage());
            e.printStackTrace(); // Log the exception for debugging
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(java.util.Collections.emptyList());
        }
    }

    @GetMapping("/pending/{id}")
    @Operation(summary = "Get pending batch by ID", description = "Retrieve a specific pending batch by its ID")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Successfully retrieved the batch",
                    content = @Content(schema = @Schema(implementation = ApprovalBatchDto.class))),
            @ApiResponse(responseCode = "404", description = "Batch not found"),
            @ApiResponse(responseCode = "400", description = "Batch is not pending approval")
    })
    public ResponseEntity<ApprovalBatchDto> getPendingBatchById(
            @Parameter(description = "Batch ID", required = true) @PathVariable Long id) {
        try {
            return batchRepository.findById(id)
                    .filter(b -> b.getPaymentStatus() != null && b.getPaymentStatus().equalsIgnoreCase("Pending"))
                    .map(this::mapBatchToApprovalDto)
                    .map(ResponseEntity::ok)
                    .orElse(ResponseEntity.notFound().build());
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

//    @PutMapping("/{id}/approve")
//    @Operation(summary = "Approve a batch", description = "Approve a pending batch with authentication")
//    @ApiResponses(value = {
//            @ApiResponse(responseCode = "200", description = "Batch approved successfully"),
//            @ApiResponse(responseCode = "400", description = "Invalid request or batch not pending"),
//            @ApiResponse(responseCode = "401", description = "Authentication failed"),
//            @ApiResponse(responseCode = "404", description = "Batch not found"),
//            @ApiResponse(responseCode = "500", description = "Internal server error")
//    })
//    public ResponseEntity<ApprovalBatchDto> approveBatch(
//            @Parameter(description = "Batch ID", required = true) @PathVariable Long id,
//            @RequestBody ApprovalRequestDto approvalRequest) {
//        try {
//            if (!"approver123".equals(approvalRequest.getPassword())) {
//                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
//            }
//            Batch batch = batchRepository.findById(id).orElse(null);
//            if (batch == null) return ResponseEntity.notFound().build();
//            if (batch.getPaymentStatus() == null || !batch.getPaymentStatus().equalsIgnoreCase("Pending")) {
//                return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
//            }
//            batch.setPaymentStatus("approved");
//            batch.setLastPaymentDate(java.time.LocalDateTime.now());
//            batchRepository.save(batch);
//            ApprovalBatchDto dto = mapBatchToApprovalDto(batch);
//            dto.setApprovedBy(approvalRequest.getApproverName());
//            dto.setApprovedDate(java.time.LocalDateTime.now());
//            dto.setApprovalComments(approvalRequest.getComments());
//            dto.setStatus("approved");
//            return ResponseEntity.ok(dto);
//        } catch (Exception e) {
//            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
//        }
//    }

    @PutMapping("/{id}/approve")
    @Transactional
    @Operation(summary = "Approve a batch", description = "Approve a pending batch with authentication")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Batch approved successfully"),
            @ApiResponse(responseCode = "400", description = "Invalid request or batch not pending"),
            @ApiResponse(responseCode = "401", description = "Authentication failed"),
            @ApiResponse(responseCode = "404", description = "Batch not found"),
            @ApiResponse(responseCode = "500", description = "Internal server error")
    })
    public ResponseEntity<ApprovalBatchDto> approveBatch(
            @Parameter(description = "Batch ID", required = true) @PathVariable Long id,
            @RequestBody ApprovalRequestDto approvalRequest,
            @RequestHeader(value = "Authorization", required = false) String authHeader) {
        try {
            // Extract user from JWT token
            String currentUserId = null;
            if (authHeader != null && authHeader.startsWith("Bearer ")) {
                String token = authHeader.substring(7);
                if (jwtTokenUtil.validateToken(token)) {
                    currentUserId = jwtTokenUtil.getUsernameFromToken(token);
                }
            }
            
            if (currentUserId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
            }
            
            // Get user and verify password
            User user = userRepository.findByUserId(currentUserId).orElse(null);
            if (user == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
            }
            
            // Verify password
            if (!passwordEncoder.matches(approvalRequest.getPassword(), user.getPassword())) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
            }
            
            Batch batch = batchRepository.findById(id).orElse(null);
            if (batch == null) return ResponseEntity.notFound().build();
            if (batch.getPaymentStatus() == null || !batch.getPaymentStatus().equalsIgnoreCase("Pending")) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
            }

            // Check if this user has already approved this batch
            if (approvalRepository.existsByBatchIdAndApprovedByAndStatus(id, currentUserId, "approved")) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);
            }

            // Check if batch has been rejected
            if (approvalRepository.existsByBatchIdAndStatus(id, "rejected")) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);
            }

            List<Employee> emps = employeeRepository.findByBatchId(id);
            BigDecimal total=emps.stream()
                    .map(Employee::getSalaryAmount)
                    .filter(Objects::nonNull)
                    .reduce(BigDecimal.ZERO,BigDecimal::add);

            // Calculate required approvers
            int approversRequired = calculateApproversRequired(total, batch.getCurrency());
            
            // Count current approved approvals
            long approvedCount = approvalRepository.countByBatchIdAndStatus(id, "approved");
            
            // Create approval record for this approver
            Approval approval = new Approval();
            approval.setBatchId(id);
            approval.setApprovedBy(currentUserId);
            approval.setStatus("approved");
            approval.setComments(approvalRequest.getComments());
            approval.setApprovedDate(java.time.LocalDateTime.now());
            approvalRepository.save(approval);
            
            // Check if we've reached the required number of approvers
            approvedCount = approvalRepository.countByBatchIdAndStatus(id, "approved");
            
            if (approvedCount >= approversRequired) {
                // All required approvers have approved - process the payment
                String accNum=batch.getDebitAccount();
                if(accNum==null || accNum.isBlank()){
                    return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);
                }

                BankAccount acct=bankAccountRepository.findByAccountNumber(accNum).orElse(null);
                if(acct==null){
                    return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
                }
                if(acct.getBalance().compareTo(total)<0){
                    return ResponseEntity.status(HttpStatus.CONFLICT).build();
                }
                acct.setBalance(acct.getBalance().subtract(total));
                bankAccountRepository.save(acct);

                for(Employee e:emps){
                    if(e.getPaymentRef() == null || e.getPaymentRef().isBlank()){
                        String token = "TRX-"+ id +"-"+ UUID.randomUUID().toString().replace("-","").substring(0,8).toUpperCase();
                        e.setPaymentRef(token);
                    }
                }

                employeeRepository.saveAll(emps);
                batch.setPaymentStatus("approved");
                batch.setLastPaymentDate(java.time.LocalDateTime.now());
                batchRepository.save(batch);
            }
            // If not fully approved yet, batch status remains "Pending"
            
            ApprovalBatchDto dto = mapBatchToApprovalDto(batch);
            dto.setApprovedBy(currentUserId);
            dto.setApprovedDate(approval.getApprovedDate());
            dto.setApprovalComments(approvalRequest.getComments());
            dto.setStatus(batch.getPaymentStatus() != null ? batch.getPaymentStatus().toLowerCase() : "pending");
            return ResponseEntity.ok(dto);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PutMapping("/{id}/reject")
    @Operation(summary = "Reject a batch", description = "Reject a pending batch with authentication")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Batch rejected successfully"),
            @ApiResponse(responseCode = "400", description = "Invalid request or batch not pending"),
            @ApiResponse(responseCode = "401", description = "Authentication failed"),
            @ApiResponse(responseCode = "404", description = "Batch not found"),
            @ApiResponse(responseCode = "500", description = "Internal server error")
    })
    public ResponseEntity<ApprovalBatchDto> rejectBatch(
            @Parameter(description = "Batch ID", required = true) @PathVariable Long id,
            @RequestBody ApprovalRequestDto approvalRequest,
            @RequestHeader(value = "Authorization", required = false) String authHeader) {
        try {
            // Extract user from JWT token
            String currentUserId = null;
            if (authHeader != null && authHeader.startsWith("Bearer ")) {
                String token = authHeader.substring(7);
                if (jwtTokenUtil.validateToken(token)) {
                    currentUserId = jwtTokenUtil.getUsernameFromToken(token);
                }
            }
            
            if (currentUserId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
            }
            
            // Get user and verify password
            User user = userRepository.findByUserId(currentUserId).orElse(null);
            if (user == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
            }
            
            // Verify password
            if (!passwordEncoder.matches(approvalRequest.getPassword(), user.getPassword())) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
            }
            
            Batch batch = batchRepository.findById(id).orElse(null);
            if (batch == null) return ResponseEntity.notFound().build();
            if (batch.getPaymentStatus() == null || !batch.getPaymentStatus().equalsIgnoreCase("Pending")) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
            }
            
            // Rejection immediately rejects the batch - no need for multiple approvers
            batch.setPaymentStatus("rejected");
            batch.setLastPaymentDate(java.time.LocalDateTime.now());
            batchRepository.save(batch);
            
            // Create approval record for rejection
            Approval approval = new Approval();
            approval.setBatchId(id);
            approval.setApprovedBy(currentUserId);
            approval.setStatus("rejected");
            approval.setComments(approvalRequest.getComments());
            approval.setApprovedDate(java.time.LocalDateTime.now());
            approvalRepository.save(approval);
            
            ApprovalBatchDto dto = mapBatchToApprovalDto(batch);
            dto.setApprovedBy(currentUserId);
            dto.setApprovedDate(approval.getApprovedDate());
            dto.setApprovalComments(approvalRequest.getComments());
            dto.setStatus("rejected");
            return ResponseEntity.ok(dto);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    private ApprovalBatchDto mapBatchToApprovalDto(Batch batch) {
        java.util.List<Employee> emps = employeeRepository.findByBatchId(batch.getId());
        java.math.BigDecimal total = emps.stream()
                .map(Employee::getSalaryAmount)
                .filter(java.util.Objects::nonNull)
                .reduce(java.math.BigDecimal.ZERO, java.math.BigDecimal::add);
        ApprovalBatchDto dto = new ApprovalBatchDto();
        dto.setId(batch.getId());
        dto.setBatchName(batch.getName());
        dto.setCreatedBy(batch.getUserId());
        dto.setCreatedDate(java.time.LocalDateTime.now());
        dto.setStatus(batch.getPaymentStatus() != null ? batch.getPaymentStatus().toLowerCase() : "pending");
        dto.setTotalAmount(total);
        dto.setCurrency(batch.getCurrency());
        dto.setEmployeeCount(emps.size());
        
        // Calculate approvers required based on amount and currency
        int approversRequired = calculateApproversRequired(total, batch.getCurrency());
        dto.setApproversRequired(approversRequired);
        
        // Count how many approvers have actually approved this batch
        long approversAssigned = approvalRepository.countByBatchIdAndStatus(batch.getId(), "approved");
        dto.setApproversAssigned((int) approversAssigned);
        
        dto.setDebitAccount(batch.getDebitAccount());
        dto.setDescription(null);
        
        // Get the most recent approval information from Approval table
        java.util.List<Approval> approvals = approvalRepository.findAllByBatchId(batch.getId());
        if (!approvals.isEmpty()) {
            // Get the most recent approval (for display purposes)
            Approval latestApproval = approvals.stream()
                    .max(java.util.Comparator.comparing(Approval::getApprovedDate))
                    .orElse(approvals.get(0));
            dto.setApprovedBy(latestApproval.getApprovedBy());
            dto.setApprovedDate(latestApproval.getApprovedDate());
            dto.setApprovalComments(latestApproval.getComments());
        }
        
        return dto;
    }
    
    /**
     * Calculate number of approvers required based on amount and currency
     * Minimum: 1 approver
     * INR: Above 7 lakhs (700,000) requires 2 approvers
     * USD: Above 100k (100,000) requires 2 approvers
     */
    private int calculateApproversRequired(java.math.BigDecimal amount, String currency) {
        if (amount == null) return 1;
        
        if ("USD".equalsIgnoreCase(currency)) {
            // USD: Above $100,000 requires 2 approvers
            java.math.BigDecimal threshold = new java.math.BigDecimal("100000");
            return amount.compareTo(threshold) > 0 ? 2 : 1;
        } else if ("INR".equalsIgnoreCase(currency)) {
            // INR: Above â‚¹7,00,000 (7 lakhs) requires 2 approvers
            java.math.BigDecimal threshold = new java.math.BigDecimal("700000");
            return amount.compareTo(threshold) > 0 ? 2 : 1;
        }
        
        return 1; // Default to 1 approver
    }

    @GetMapping("/{id}/check-approval")
    @Operation(summary = "Check if current user has approved a batch", description = "Check if the current logged-in user has already approved the specified batch")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Check completed successfully"),
            @ApiResponse(responseCode = "401", description = "Unauthorized"),
            @ApiResponse(responseCode = "404", description = "Batch not found")
    })
    public ResponseEntity<java.util.Map<String, Object>> checkUserApproval(
            @Parameter(description = "Batch ID", required = true) @PathVariable Long id,
            @RequestHeader(value = "Authorization", required = false) String authHeader) {
        try {
            String currentUserId = null;
            if (authHeader != null && authHeader.startsWith("Bearer ")) {
                String token = authHeader.substring(7);
                if (jwtTokenUtil.validateToken(token)) {
                    currentUserId = jwtTokenUtil.getUsernameFromToken(token);
                }
            }
            
            if (currentUserId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
            }
            
            boolean hasApproved = approvalRepository.existsByBatchIdAndApprovedByAndStatus(id, currentUserId, "approved");
            boolean hasRejected = approvalRepository.existsByBatchIdAndApprovedByAndStatus(id, currentUserId, "rejected");
            
            java.util.Map<String, Object> response = new java.util.HashMap<>();
            response.put("hasApproved", hasApproved);
            response.put("hasRejected", hasRejected);
            
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @GetMapping("/statistics")
    @Operation(summary = "Get approval statistics", description = "Get statistics about pending and reviewed batches")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Successfully retrieved statistics",
                    content = @Content(schema = @Schema(implementation = ApprovalStatisticsDto.class))),
            @ApiResponse(responseCode = "500", description = "Internal server error")
    })
    public ResponseEntity<ApprovalStatisticsDto> getApprovalStatistics() {
        try {
            ApprovalStatisticsDto statistics = approvalService.getApprovalStatistics();
            return ResponseEntity.ok(statistics);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

}


import React, { useState, useEffect, useCallback } from 'react';
import PayrollCard from './PayrollCard';
import PayrollDetailsModal from './PayrollDetailsModal';
import ApprovalService from '../../services/ApprovalService';
import { getEmployees } from '../../services/payrollapi';
import { getCurrentUser } from '../../services/api';

const ApproverPage = () => {
  const [payrolls, setPayrolls] = useState([]);
  const [selectedPayroll, setSelectedPayroll] = useState(null);
  const [showDetailsModal, setShowDetailsModal] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [allEmployees, setAllEmployees] = useState([]);
  const [searchId, setSearchId] = useState('');
  const [showAuthModal, setShowAuthModal] = useState(false);
  const [authPassword, setAuthPassword] = useState('');
  const [rejectionComment, setRejectionComment] = useState('');
  const [pendingAction, setPendingAction] = useState(null);
  const [authError, setAuthError] = useState('');
  const [currentUserId, setCurrentUserId] = useState(null);
  const [userApprovals, setUserApprovals] = useState({}); // Track which batches user has approved

  // Helper to reload batches after approval
  const loadPendingBatches = useCallback(async () => {
    setIsLoading(true);
    try {
      const apiBatches = await ApprovalService.getPendingBatches();
      const transformedBatches = apiBatches
        .map(ApprovalService.transformBatchData)
        .filter(b => (b.debitAccount && String(b.debitAccount).trim() !== '') && (b.currency && String(b.currency).trim() !== ''));
      setPayrolls(transformedBatches);
      
      // Check which batches the current user has already approved
      if (currentUserId) {
        const approvals = {};
        for (const batch of transformedBatches) {
          try {
            const checkResult = await ApprovalService.checkUserApproval(batch.id);
            approvals[batch.id] = checkResult.hasApproved || false;
          } catch (err) {
            console.error(`Error checking approval for batch ${batch.id}:`, err);
            approvals[batch.id] = false;
          }
        }
        setUserApprovals(approvals);
      }
      
      try {
        const employees = await getEmployees();
        setAllEmployees(Array.isArray(employees) ? employees : []);
      } catch (empErr) {
        console.error('Error loading employees:', empErr);
        setAllEmployees([]);
      }
    } catch (error) {
      console.error('Error loading pending batches:', error);
      setPayrolls([]);
    } finally {
      setIsLoading(false);
    }
  }, [currentUserId]);

  // Load current user
  useEffect(() => {
    const loadCurrentUser = async () => {
      try {
        const userData = await getCurrentUser();
        setCurrentUserId(userData.userId);
      } catch (error) {
        console.error('Error loading current user:', error);
      }
    };

    loadCurrentUser();
  }, []);

  // Load batches when current user is loaded
  useEffect(() => {
    if (currentUserId) {
      loadPendingBatches();
    }
  }, [currentUserId, loadPendingBatches]);

  const handleViewDetails = (payroll) => {
    setSelectedPayroll(payroll);
    setShowDetailsModal(true);
  };

  const handleCloseModal = () => {
    setShowDetailsModal(false);
    setSelectedPayroll(null);
  };

  const handleAuthPrompt = (action, payrollId) => {
    setPendingAction({ action, payrollId });
    setShowAuthModal(true);
    setAuthPassword('');
    setRejectionComment('');
    setAuthError('');
  };

  const handleAuthSubmit = async () => {
    if (!authPassword.trim()) {
      setAuthError('Please enter your password.');
      return;
    }
    
    // For reject action, require a comment
    if (pendingAction.action === 'reject' && !rejectionComment.trim()) {
      setAuthError('Please enter a rejection comment.');
      return;
    }
    
    setShowAuthModal(false);
    setAuthError('');
    
    // Execute the pending action - password will be verified on the backend
    if (pendingAction.action === 'approve') {
      handleApprove(pendingAction.payrollId);
    } else if (pendingAction.action === 'reject') {
      handleReject(pendingAction.payrollId);
    }
    
    setPendingAction(null);
  };

  const handleAuthCancel = () => {
    setShowAuthModal(false);
    setPendingAction(null);
    setAuthPassword('');
    setRejectionComment('');
    setAuthError('');
  };

  const handleApprove = async (payrollId) => {
    setIsLoading(true);
    
    try {
      const item = payrolls.find(p => p.id === payrollId);
      const batchId = item?.batchId || item?.id;
      const approvalData = {
        action: 'approve',
        password: authPassword,
        comments: 'Approved',
        approverName: currentUserId || 'Approver'
      };
      
      await ApprovalService.approveBatch(batchId, approvalData);
      
      // Update user approvals state
      setUserApprovals(prev => ({ ...prev, [payrollId]: true }));
      
      // Reload batches to get updated approver count
      await loadPendingBatches();
      
      // Get updated batch data after reload
      const updatedPayrolls = await ApprovalService.getPendingBatches();
      const transformedBatches = updatedPayrolls
        .map(ApprovalService.transformBatchData)
        .filter(b => (b.debitAccount && String(b.debitAccount).trim() !== '') && (b.currency && String(b.currency).trim() !== ''));
      const updatedItem = transformedBatches.find(p => String(p.id) === String(payrollId));
      
      // Show success message
      if (updatedItem) {
        const approversAssigned = updatedItem.approversAssigned || 0;
        const approversRequired = updatedItem.approversRequired || 1;
        if (approversAssigned >= approversRequired) {
          alert('Payroll batch approved successfully! All required approvers have approved.');
        } else {
          alert(`Payroll batch approved successfully! ${approversAssigned}/${approversRequired} approvers have approved.`);
        }
      } else {
        // Batch is fully approved and removed from pending
        alert('Payroll batch approved successfully! All required approvers have approved.');
      }
      
      // Close modal if open
      if (showDetailsModal) {
        handleCloseModal();
      }
      try {
        window.dispatchEvent(new Event('approvals:updated'));
      } catch (_) {}
    } catch (error) {
      console.error('Error approving batch:', error);
      if (error.status === 401 || (error.message && error.message.includes('401'))) {
        alert('Invalid password. Please try again.');
        setShowAuthModal(true);
        setPendingAction({ action: 'approve', payrollId });
        setAuthPassword('');
        setAuthError('Invalid password. Please try again.');
      } else {
        alert(`Error approving batch: ${error.message || 'Unknown error'}`);
      }
    } finally {
      setIsLoading(false);
    }
  };

  const handleReject = async (payrollId) => {
    setIsLoading(true);
    
    try {
      const item = payrolls.find(p => p.id === payrollId);
      const batchId = item?.batchId || item?.id;
      const approvalData = {
        action: 'reject',
        password: authPassword,
        comments: rejectionComment.trim() || 'Rejected',
        approverName: currentUserId || 'Approver'
      };
      
      await ApprovalService.rejectBatch(batchId, approvalData);
      
      // Remove from pending list
      setPayrolls(prevPayrolls => 
        prevPayrolls.filter(payroll => payroll.id !== payrollId)
      );
      
      // Close modal if open
      if (showDetailsModal) {
        handleCloseModal();
      }
      
      // Show success message
      alert('Payroll batch rejected successfully!');
      try {
        window.dispatchEvent(new Event('approvals:updated'));
      } catch (_) {}
    } catch (error) {
      console.error('Error rejecting batch:', error);
      if (error.status === 401 || (error.message && error.message.includes('401'))) {
        alert('Invalid password. Please try again.');
        setShowAuthModal(true);
        setPendingAction({ action: 'reject', payrollId });
        setAuthPassword('');
        setAuthError('Invalid password. Please try again.');
      } else {
        alert(`Error rejecting batch: ${error.message || 'Unknown error'}`);
      }
    } finally {
      setIsLoading(false);
    }
  };

  // Filter only pending payrolls and apply search filter
  const pendingPayrolls = payrolls.filter(payroll => {
    const isPending = payroll.status === 'pending';
    const matchesSearch = searchId === '' || payroll.id.toLowerCase().includes(searchId.toLowerCase());
    return isPending && matchesSearch;
  }).sort((a, b) => new Date(a.createdDate) - new Date(b.createdDate)); // Sort by created date (oldest first)

  return (
    <div className="approver-page">
      <div className="container">
        {/* Header */}
        <div className="page-header">
          <h1 className="page-title">Payroll Approval Dashboard</h1>
          <p className="page-subtitle">
            Review and approve pending payroll batches
          </p>
        </div>

        {/* Statistics */}
        <div className="stats-section">
              <div className="stat-card">
                <div className="stat-icon pending"></div>
            <div className="stat-content">
              <div className="stat-value">{pendingPayrolls.length}</div>
              <div className="stat-label">Pending Approvals</div>
            </div>
          </div>
              <div className="stat-card">
                <div className="stat-icon usd"></div>
            <div className="stat-content">
              <div className="stat-value">
                {pendingPayrolls
                  .filter(p => p.currency === 'USD')
                  .reduce((sum, p) => sum + p.totalAmount, 0)
                  .toLocaleString('en-US', {
                    style: 'currency',
                    currency: 'USD',
                    minimumFractionDigits: 0
                  })}
              </div>
              <div className="stat-label">USD Amount</div>
            </div>
          </div>
              <div className="stat-card">
                <div className="stat-icon inr"></div>
            <div className="stat-content">
              <div className="stat-value">
                {pendingPayrolls
                  .filter(p => p.currency === 'INR')
                  .reduce((sum, p) => sum + p.totalAmount, 0)
                  .toLocaleString('en-IN', {
                    style: 'currency',
                    currency: 'INR',
                    minimumFractionDigits: 0
                  })}
              </div>
              <div className="stat-label">INR Amount</div>
            </div>
          </div>
              <div className="stat-card">
                <div className="stat-icon employees"></div>
            <div className="stat-content">
              <div className="stat-value">
                {pendingPayrolls.reduce((sum, p) => sum + p.employeeCount, 0)}
              </div>
              <div className="stat-label">Total Employees</div>
            </div>
          </div>
        </div>

        {/* Search Bar */}
        <div className="search-section">
          <div className="search-container">
            <div className="search-input-group">
                  <div className="search-icon"></div>
              <input
                type="text"
                className="search-input"
                placeholder="Search by Batch ID (e.g., USD-2024-001, INR-2024-001)"
                value={searchId}
                onChange={(e) => setSearchId(e.target.value)}
              />
              {searchId && (
                <button 
                  className="search-clear"
                  onClick={() => setSearchId('')}
                >
Ã—
                </button>
              )}
            </div>
            <div className="search-info">
              {searchId ? (
                <span>Showing {pendingPayrolls.length} result{pendingPayrolls.length !== 1 ? 's' : ''} for "{searchId}"</span>
              ) : (
                <span>Search by batch ID to filter results</span>
              )}
            </div>
          </div>
        </div>

        {/* Payroll Cards */}
        <div className="payrolls-section">
          <div className="section-header">
            <h2 className="section-title">Pending Payroll Batches</h2>
            <div className="section-count">
              {pendingPayrolls.length} batch{pendingPayrolls.length !== 1 ? 'es' : ''} pending
            </div>
          </div>

          {pendingPayrolls.length === 0 ? (
            <div className="empty-state">
              <div className="empty-icon">ðŸŽ‰</div>
              <h3>All caught up!</h3>
              <p>No payroll batches are currently pending approval.</p>
              <div style={{ marginTop: '24px', display: 'flex', flexDirection: 'column', gap: '12px', alignItems: 'center' }}>
                <p style={{ color: '#64748b', fontSize: '14px' }}>What would you like to do next?</p>
                <div style={{ display: 'flex', gap: '12px', flexWrap: 'wrap', justifyContent: 'center' }}>
                  <button 
                    className="btn btn-outline"
                    onClick={() => window.location.reload()}
                    style={{ fontSize: '14px' }}
                  >
                    ðŸ”„ Refresh Page
                  </button>
                  <button 
                    className="btn btn-outline"
                    onClick={() => {
                      // Clear localStorage to reset demo data
                      localStorage.removeItem('approvals');
                      window.location.reload();
                    }}
                    style={{ fontSize: '14px' }}
                  >
                    ðŸ”„ Reset Demo Data
                  </button>
                  <button 
                    className="btn btn-primary"
                    onClick={() => window.location.href = '/approvals'}
                    style={{ fontSize: '14px' }}
                  >
                    ðŸ“‹ View Reviewed Batches
                  </button>
                </div>
                <div style={{ marginTop: '16px', padding: '16px', backgroundColor: '#f8fafc', borderRadius: '8px', border: '1px solid #e5e7eb', maxWidth: '400px', textAlign: 'center' }}>
                  <p style={{ fontSize: '12px', color: '#64748b', margin: '0' }}>
                    <strong>Demo Tip:</strong> Click "Reset Demo Data" to restore all sample batches for testing.
                  </p>
                </div>
              </div>
            </div>
          ) : (
            <div className="payrolls-grid">
              {pendingPayrolls.map(payroll => (
                <PayrollCard
                  key={payroll.id}
                  payroll={payroll}
                  onViewDetails={handleViewDetails}
                  onApprove={(id) => handleAuthPrompt('approve', id)}
                  onReject={(id) => handleAuthPrompt('reject', id)}
                  isLoading={isLoading}
                  hasUserApproved={userApprovals[payroll.id] || false}
                />
              ))}
            </div>
          )}
        </div>

        {/* Details Modal */}
        {showDetailsModal && (
          <PayrollDetailsModal
            payroll={selectedPayroll}
            employees={allEmployees.filter(e => String(e.batchId || '') === String(selectedPayroll?.id || ''))}
            onClose={handleCloseModal}
            onApprove={(id) => handleAuthPrompt('approve', id)}
            onReject={(id) => handleAuthPrompt('reject', id)}
            isLoading={isLoading}
            hasUserApproved={selectedPayroll ? (userApprovals[selectedPayroll.id] || false) : false}
          />
        )}

        {/* Authentication Modal */}
        {showAuthModal && (
          <div className="modal-overlay">
            <div className="modal">
              <div className="modal-header">
                <h3 className="modal-title">Authentication Required</h3>
                <button className="modal-close" onClick={handleAuthCancel}>Ã—</button>
              </div>
              <div className="modal-body">
                <p>Please enter your login password to {pendingAction?.action} this payroll batch:</p>
                
                {pendingAction?.action === 'reject' && (
                  <div className="form-group">
                    <label className="form-label">Rejection Comment *</label>
                    <textarea
                      className="form-input"
                      value={rejectionComment}
                      onChange={(e) => {
                        setRejectionComment(e.target.value);
                        setAuthError('');
                      }}
                      placeholder="Enter reason for rejection..."
                      rows={3}
                      style={{ resize: 'vertical', minHeight: '80px' }}
                    />
                  </div>
                )}
                
                <div className="form-group">
                  <label className="form-label">Password *</label>
                  <input
                    type="password"
                    className="form-input"
                    value={authPassword}
                    onChange={(e) => {
                      setAuthPassword(e.target.value);
                      setAuthError('');
                    }}
                    onKeyPress={(e) => {
                      if (e.key === 'Enter' && authPassword.trim() && (pendingAction?.action === 'approve' || rejectionComment.trim())) {
                        handleAuthSubmit();
                      }
                    }}
                    placeholder="Enter your login password"
                    autoFocus={pendingAction?.action === 'approve'}
                  />
                  {authError && (
                    <div style={{ color: '#ef4444', fontSize: '14px', marginTop: '8px' }}>
                      {authError}
                    </div>
                  )}
                </div>
              </div>
              <div className="modal-footer">
                <button className="btn btn-outline" onClick={handleAuthCancel}>
                  Cancel
                </button>
                <button 
                  className="btn btn-primary" 
                  onClick={handleAuthSubmit}
                  disabled={!authPassword.trim() || isLoading || (pendingAction?.action === 'reject' && !rejectionComment.trim())}
                >
                  {isLoading ? 'Processing...' : (pendingAction?.action === 'approve' ? 'Approve' : 'Reject')}
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default ApproverPage;


  // ------------------ Check if user has approved a batch ------------------
  static async checkUserApproval(batchId) {
    try {
      const response = await apiFetch(`/api/approvals/${batchId}/check-approval`, { method: "GET" });
      if (!response.ok) throw new Error(`Error checking approval: ${response.status}`);
      return await response.json();
    } catch (error) {
      console.error("Error checking user approval:", error);
      throw error;
    }
  }


package paymentinitiationbackend.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import paymentinitiationbackend.model.Approval;

import java.util.List;
import java.util.Optional;

@Repository
public interface ApprovalRepository extends JpaRepository<Approval, Long> {
    
    Optional<Approval> findByBatchId(Long batchId);
    
    boolean existsByBatchId(Long batchId);
    
    // Find all approvals for a batch
    List<Approval> findAllByBatchId(Long batchId);
    
    // Count approved approvals for a batch
    long countByBatchIdAndStatus(Long batchId, String status);
    
    // Check if a user has already approved a batch
    boolean existsByBatchIdAndApprovedByAndStatus(Long batchId, String approvedBy, String status);
}

import React from 'react';
import "./ApprovalPayment.css";
const ActionButtons = ({ onApprove, onReject, isLoading = false, approversAssigned = 0, approversRequired = 1, hasUserApproved = false }) => {
  const isFullyApproved = approversAssigned >= approversRequired;
  const canApprove = !isLoading && !hasUserApproved && !isFullyApproved;
  
  return (
    <div className="action-buttons">
      <button 
        className="btn btn-success"
        onClick={onApprove}
        disabled={!canApprove}
        title={hasUserApproved ? "You have already approved this batch" : isFullyApproved ? "All required approvers have approved" : ""}
      >
        {isLoading ? 'Loading...' : hasUserApproved ? 'Already Approved' : isFullyApproved ? 'Fully Approved' : 'Approve'} 
      </button>
      <button 
        className="btn btn-danger"
        onClick={onReject}
        disabled={isLoading || isFullyApproved}
        title={isFullyApproved ? "Batch is fully approved and cannot be rejected" : ""}
      >
        {isLoading ? 'Loading...' : 'Reject'} 
      </button>
    </div>
  );
};

export default ActionButtons;

import React from 'react';
import ActionButtons from './ActionButtons';

const PayrollCard = ({ payroll, onViewDetails, onApprove, onReject, isLoading, hasUserApproved = false }) => {
  const formatCurrency = (amount, currency) => {
    if (currency === 'INR') {
      return new Intl.NumberFormat('en-IN', {
        style: 'currency',
        currency: 'INR'
      }).format(amount);
    } else {
      return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD'
      }).format(amount);
    }
  };

  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    });
  };

  return (
    <div className="payroll-card">
      <div className="payroll-card-header">
        <div className="payroll-card-title">
          <div className="batch-id">ID: {payroll.id}</div>
          <h3>{payroll.batchName}</h3>
          <div className={`status-badge status-${payroll.status}`}>
            {payroll.status.toUpperCase()}
          </div>
        </div>
        <div className="payroll-card-amount">
          {formatCurrency(payroll.totalAmount, payroll.currency)}
        </div>
      </div>

      <div className="payroll-card-body">
        <div className="payroll-card-details">
          <div className="payroll-detail">
            <span className="detail-label">Employees</span>
            <span className="detail-value">{payroll.employeeCount}</span>
          </div>
          <div className="payroll-detail">
            <span className="detail-label">Debit Account</span>
            <span className="detail-value">{payroll.debitAccount || 'N/A'}</span>
          </div>
          <div className="payroll-detail">
            <span className="detail-label">Currency</span>
            <span className="detail-value">{payroll.currency}</span>
          </div>
          <div className="payroll-detail">
            <span className="detail-label">Approvers</span>
            <span className="detail-value">
              {payroll.approversAssigned}/{payroll.approversRequired}
            </span>
          </div>
          <div className="payroll-detail">
            <span className="detail-label">Created By</span>
            <span className="detail-value">{payroll.createdBy}</span>
          </div>
          <div className="payroll-detail">
            <span className="detail-label">Date</span>
            <span className="detail-value">{formatDate(payroll.createdDate)}</span>
          </div>
        </div>

        {payroll.description && (
          <div className="payroll-card-description">
            <p>{payroll.description}</p>
          </div>
        )}
      </div>

      <div className="payroll-card-footer">
        <button 
          className="btn btn-outline"
          onClick={() => onViewDetails(payroll)}
        >
          View Details
        </button>
        
        <ActionButtons
          onApprove={() => onApprove(payroll.id)}
          onReject={() => onReject(payroll.id)}
          isLoading={isLoading}
          approversAssigned={payroll.approversAssigned || 0}
          approversRequired={payroll.approversRequired || 1}
          hasUserApproved={hasUserApproved}
        />
      </div>
    </div>
  );
};

export default PayrollCard;

import React from 'react';
import ActionButtons from './ActionButtons';

const PayrollDetailsModal = ({ payroll, employees = [], onClose, onApprove, onReject, isLoading, showActionButtons = true, hasUserApproved = false }) => {
  if (!payroll) return null;

  const formatCurrency = (amount, currency) => {
    if (currency === 'INR') {
      return new Intl.NumberFormat('en-IN', {
        style: 'currency',
        currency: 'INR'
      }).format(amount);
    } else {
      return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD'
      }).format(amount);
    }
  };

  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });
  };

  return (
    <div className="modal-overlay">
      <div className="modal payroll-details-modal">
        <div className="modal-header">
          <h2 className="modal-title">Payroll Batch Details</h2>
          <button className="modal-close" onClick={onClose}>Ã—</button>
        </div>

        <div className="modal-body">
          {/* Header Section */}
          <div className="details-header">
            <div className="details-title-section">
              <div className="details-batch-id">Batch ID: {payroll.id}</div>
              <h3 className="details-title">{payroll.batchName}</h3>
              <div className={`status-badge status-${payroll.status}`}>
                {payroll.status.toUpperCase()}
              </div>
            </div>
            <div className="details-amount">
              <div className="amount-value">{formatCurrency(payroll.totalAmount, payroll.currency)}</div>
              <div className="amount-label">Total Amount ({payroll.currency})</div>
            </div>
          </div>

          {/* Description */}
          {payroll.description && (
            <div className="details-description">
              <h4>Description</h4>
              <p>{payroll.description}</p>
            </div>
          )}

          {/* Key Metrics */}
          <div className="details-metrics">
            <div className="metric-card">
              <div className="metric-icon"></div>
              <div className="metric-content">
                <div className="metric-value">{payroll.employeeCount}</div>
                <div className="metric-label">Employees</div>
              </div>
            </div>
            <div className="metric-card">
              <div className="metric-icon"></div>
              <div className="metric-content">
                <div className="metric-value">{payroll.currency}</div>
                <div className="metric-label">Currency</div>
              </div>
            </div>
            <div className="metric-card">
              <div className="metric-icon"></div>
              <div className="metric-content">
                <div className="metric-value">
                  {payroll.approversAssigned}/{payroll.approversRequired}
                </div>
                <div className="metric-label">Approvers</div>
              </div>
            </div>
            <div className="metric-card">
              <div className="metric-icon"></div>
              <div className="metric-content">
                <div className="metric-value">{payroll.debitAccount || 'N/A'}</div>
                <div className="metric-label">Debit Account</div>
              </div>
            </div>
            <div className="metric-card">
              <div className="metric-icon"></div>
              <div className="metric-content">
                <div className="metric-value">{payroll.createdBy}</div>
                <div className="metric-label">Created By</div>
              </div>
            </div>
            <div className="metric-card">
              <div className="metric-icon"></div>
              <div className="metric-content">
                <div className="metric-value">{formatDate(payroll.createdDate)}</div>
                <div className="metric-label">Created Date</div>
              </div>
            </div>
          </div>

          {/* Employee Breakdown */}
          <div className="details-breakdown">
            <h4>Employee Breakdown</h4>
            <div className="breakdown-table">
              <div className="table-header">
                <div className="table-cell">Employee ID</div>
                <div className="table-cell">Name</div>
                <div className="table-cell">Department</div>
                <div className="table-cell">Amount</div>
              </div>
              {(employees && employees.length > 0
                ? employees
                : Array.from({ length: payroll.employeeCount }, (_, i) => ({
                    id: `EMP${String(i + 1).padStart(3, '0')}`,
                    name: `Employee ${i + 1}`,
                    department: 'â€”',
                    salaryAmount: (payroll.totalAmount || 0) / Math.max(1, payroll.employeeCount)
                  }))
              ).map((emp, idx) => (
                <div key={emp.id || idx} className="table-row">
                  <div className="table-cell">{emp.id || `EMP${String(idx + 1).padStart(3, '0')}`}</div>
                  <div className="table-cell">{emp.name || `Employee ${idx + 1}`}</div>
                  <div className="table-cell">{emp.department || 'â€”'}</div>
                  <div className="table-cell amount">{formatCurrency(Number(emp.salaryAmount || 0), payroll.currency)}</div>
                </div>
              ))}
            </div>
          </div>

          {/* Decision Details (only for reviewed batches) */}
          {payroll.status !== 'pending' && (
            <div className="details-description">
              <h4>Decision</h4>
              <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '12px' }}>
                <div>
                  <div style={{ fontSize: '12px', color: '#64748b' }}>Status</div>
                  <div style={{ fontWeight: 600, marginTop: '4px' }}>{payroll.status?.toUpperCase()}</div>
                </div>
                <div>
                  <div style={{ fontSize: '12px', color: '#64748b' }}>Decision Date</div>
                  <div style={{ fontWeight: 600, marginTop: '4px' }}>{payroll.approvedDate ? formatDate(payroll.approvedDate) : 'â€”'}</div>
                </div>
                <div>
                  <div style={{ fontSize: '12px', color: '#64748b' }}>Approved By</div>
                  <div style={{ fontWeight: 600, marginTop: '4px' }}>{payroll.approvedBy || 'â€”'}</div>
                </div>
                <div>
                  <div style={{ fontSize: '12px', color: '#64748b' }}>Comments</div>
                  <div style={{ fontWeight: 600, marginTop: '4px', wordBreak: 'break-word' }}>{payroll.approvalComments || 'â€”'}</div>
                </div>
              </div>
            </div>
          )}
        </div>

        <div className="modal-footer">
          <button className="btn btn-outline" onClick={onClose}>
            Close
          </button>
          {showActionButtons && (
            <ActionButtons
              onApprove={() => onApprove(payroll.id)}
              onReject={() => onReject(payroll.id)}
              isLoading={isLoading}
              approversAssigned={payroll.approversAssigned || 0}
              approversRequired={payroll.approversRequired || 1}
              hasUserApproved={hasUserApproved}
            />
          )}
        </div>
      </div>
    </div>
  );
};

export default PayrollDetailsModal;
