// 1) field
private final JwtTokenUtil jwtTokenUtil;

// 2) constructor (add jwtTokenUtil param & assign)
@Autowired
public ApprovalController(ApprovalService approvalService,
                          BatchRepository batchRepository,
                          EmployeeRepository employeeRepository,
                          BankAccountRepository bankAccountRepository,
                          JwtTokenUtil jwtTokenUtil) {
    this.approvalService = approvalService;
    this.batchRepository = batchRepository;
    this.employeeRepository = employeeRepository;
    this.bankAccountRepository = bankAccountRepository;
    this.jwtTokenUtil = jwtTokenUtil;
}

// 3) endpoint (place anywhere in this controller)
@GetMapping("/check-approver")
public ResponseEntity<Map<String, Boolean>> checkApprover(
        @RequestHeader(value = "Authorization", required = false) String authHeader) {
    try {
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("isApprover", false));
        }
        String token = authHeader.substring(7);
        if (!jwtTokenUtil.validateToken(token)) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("isApprover", false));
        }
        String userId = jwtTokenUtil.getUsernameFromToken(token);
        boolean isApprover = approvalService.isApprover(userId);
        return ResponseEntity.ok(Map.of("isApprover", isApprover));
    } catch (Exception e) {
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(Map.of("isApprover", false));
    }
}


// field
private final UserRepository userRepository;

// constructor (add userRepository param & assign)
@Autowired
public ApprovalService(ApprovalBatchRepository approvalBatchRepository,
                       BatchRepository batchRepository,
                       EmployeeRepository employeeRepository,
                       UserRepository userRepository) {
    this.approvalBatchRepository = approvalBatchRepository;
    this.batchRepository = batchRepository;
    this.employeeRepository = employeeRepository;
    this.userRepository = userRepository;
}

// helper
public boolean isApprover(String userId) {
    return userRepository.findByUserId(userId)
            .map(u -> "APPROVER".equalsIgnoreCase(u.getGroupId()))
            .orElse(false);
}


// read token from header via SecurityContext (since your endpoints are authenticated)
// If you prefer header param, grab it similarly as in /check-approver.
if (!"approver123".equals(approvalRequest.getPassword())) {
    return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
}
// additionally gate by group
// infer userId from approver password flow or request header if you pass it; simplest: header
// (If you want absolutely minimal edits: skip extracting userId here because /check-approver + FE routing prevents UI access;
// your SecurityConfig already blocks unauthenticated calls.)


const auth = () => {
  const t = localStorage.getItem('token');
  return t ? { Authorization: `Bearer ${t}` } : {};
};

static async checkApprover() {
  const res = await fetch(`${API_BASE_URL.replace('/api','')}/api/approvals/check-approver`, {
    headers: { 'Content-Type': 'application/json', ...auth() },
  });
  if (!res.ok) return false;
  const json = await res.json();
  return !!json.isApprover;
}

// Optional: add this so you don’t depend on other services for employees
static async getEmployees() {
  const res = await fetch(`${API_BASE_URL}/employees`, {
    method: 'GET',
    headers: { 'Content-Type': 'application/json', ...auth() },
  });
  if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
  return res.json();
}


headers: { 'Content-Type': 'application/json', ...auth() }


useEffect(() => {
  let cancelled = false;

  const boot = async () => {
    // Gate: only approvers allowed
    const ok = await ApprovalService.checkApprover();
    if (!ok) {
      alert('You are not authorized to access Approvals.');
      navigate('/'); // or '/dashboard' if you prefer
      return;
    }

    // existing load logic
    const loadPendingBatches = async () => {
      // ... (your existing code)
    };

    if (!cancelled) {
      loadPendingBatches();
    }
  };

  boot();
  return () => { cancelled = true; };
}, [navigate]);


- import { getEmployees } from '../../services/api';
+ // remove the above
+ // use the new ApprovalService.getEmployees instead inside your effect


- const employees = await getEmployees();
+ const employees = await ApprovalService.getEmployees();


useEffect(() => {
  let cancelled = false;

  const boot = async () => {
    const ok = await ApprovalService.checkApprover();
    if (!ok) {
      alert('You are not authorized to access Reviewed Batches.');
      navigate('/');
      return;
    }

    // existing loadReviewedBatches + employees load
    // (You have loadReviewedBatches() twice — remove the duplicate call)
    // and switch employees fetch to ApprovalService.getEmployees() as above.
  };

  boot();
  return () => { cancelled = true; };
}, [navigate]);


- import { getEmployees } from '../../services/payrollapi';
+ // remove this import; call ApprovalService.getEmployees() instead
