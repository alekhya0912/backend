package paymentinitiationbackend.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.transaction.Transactional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import paymentinitiationbackend.dto.ApprovalBatchDto;
import paymentinitiationbackend.dto.ApprovalRequestDto;
import paymentinitiationbackend.dto.ApprovalStatisticsDto;
import paymentinitiationbackend.model.Approval;
import paymentinitiationbackend.model.BankAccount;
import paymentinitiationbackend.model.Batch;
import paymentinitiationbackend.model.Employee;
import paymentinitiationbackend.model.User;
import paymentinitiationbackend.repository.ApprovalRepository;
import paymentinitiationbackend.repository.BankAccountRepository;
import paymentinitiationbackend.repository.BatchRepository;
import paymentinitiationbackend.repository.EmployeeRepository;
import paymentinitiationbackend.repository.UserRepository;
import paymentinitiationbackend.service.ApprovalService;
import paymentinitiationbackend.config.JwtTokenUtil;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.math.BigDecimal;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

@RestController
@RequestMapping("/api/approvals")
@Tag(name = "Approval Management", description = "APIs for managing payroll batch approvals")
public class ApprovalController {

    private final ApprovalService approvalService;
    private final BatchRepository batchRepository;
    private final EmployeeRepository employeeRepository;
    private final BankAccountRepository bankAccountRepository;
    private final UserRepository userRepository;
    private final ApprovalRepository approvalRepository;
    private final JwtTokenUtil jwtTokenUtil;
    private final PasswordEncoder passwordEncoder;

    @Autowired
    public ApprovalController(ApprovalService approvalService,
                              BatchRepository batchRepository,
                              EmployeeRepository employeeRepository,
                              BankAccountRepository bankAccountRepository,
                              UserRepository userRepository,
                              ApprovalRepository approvalRepository,
                              JwtTokenUtil jwtTokenUtil,
                              PasswordEncoder passwordEncoder) {
        this.approvalService = approvalService;
        this.batchRepository = batchRepository;
        this.employeeRepository = employeeRepository;
        this.bankAccountRepository=bankAccountRepository;
        this.userRepository = userRepository;
        this.approvalRepository = approvalRepository;
        this.jwtTokenUtil = jwtTokenUtil;
        this.passwordEncoder = passwordEncoder;
    }

    @GetMapping("/pending")
    @Operation(summary = "Get pending batches", description = "Retrieve all batches that are pending approval")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Successfully retrieved pending batches",
                    content = @Content(schema = @Schema(implementation = ApprovalBatchDto.class))),
            @ApiResponse(responseCode = "500", description = "Internal server error")
    })
    public ResponseEntity<List<ApprovalBatchDto>> getPendingBatches() {
        try {
            List<Batch> batches = batchRepository.findAll();
            List<ApprovalBatchDto> pending = batches.stream()
                    .filter(b -> b.getPaymentStatus() != null && b.getPaymentStatus().equalsIgnoreCase("Pending"))
                    .filter(b -> b.getDebitAccount() != null && !b.getDebitAccount().trim().isEmpty())
                    .filter(b -> b.getCurrency() != null && !b.getCurrency().trim().isEmpty())
                    .map(this::mapBatchToApprovalDto)
                    .toList();
            return ResponseEntity.ok(pending);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @GetMapping("/reviewed")
    @Operation(summary = "Get reviewed batches", description = "Retrieve all batches that have been approved or rejected")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Successfully retrieved reviewed batches",
                    content = @Content(schema = @Schema(implementation = ApprovalBatchDto.class))),
            @ApiResponse(responseCode = "500", description = "Internal server error")
    })
    public ResponseEntity<List<ApprovalBatchDto>> getReviewedBatches() {
        try {
            List<Batch> batches = batchRepository.findAll();
            System.out.println("Total batches found: " + batches.size());
            // Filter for approved or rejected batches
            List<ApprovalBatchDto> reviewed = batches.stream()
                    .filter(b -> {
                        String status = b.getPaymentStatus();
                        System.out.println("Batch ID: " + b.getId() + ", Status: " + status);
                        boolean isReviewed = status != null && (status.equalsIgnoreCase("approved") || status.equalsIgnoreCase("rejected"));
                        if (isReviewed) {
                            System.out.println("Batch " + b.getId() + " is reviewed (status: " + status + ")");
                        }
                        return isReviewed;
                    })
                    .map(this::mapBatchToApprovalDto)
                    .toList();
            System.out.println("Reviewed batches count: " + reviewed.size());
            return ResponseEntity.ok(reviewed);
        } catch (Exception e) {
            e.printStackTrace(); // Log the exception for debugging
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @GetMapping("/pending/{id}")
    @Operation(summary = "Get pending batch by ID", description = "Retrieve a specific pending batch by its ID")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Successfully retrieved the batch",
                    content = @Content(schema = @Schema(implementation = ApprovalBatchDto.class))),
            @ApiResponse(responseCode = "404", description = "Batch not found"),
            @ApiResponse(responseCode = "400", description = "Batch is not pending approval")
    })
    public ResponseEntity<ApprovalBatchDto> getPendingBatchById(
            @Parameter(description = "Batch ID", required = true) @PathVariable Long id) {
        try {
            return batchRepository.findById(id)
                    .filter(b -> b.getPaymentStatus() != null && b.getPaymentStatus().equalsIgnoreCase("Pending"))
                    .map(this::mapBatchToApprovalDto)
                    .map(ResponseEntity::ok)
                    .orElse(ResponseEntity.notFound().build());
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

//    @PutMapping("/{id}/approve")
//    @Operation(summary = "Approve a batch", description = "Approve a pending batch with authentication")
//    @ApiResponses(value = {
//            @ApiResponse(responseCode = "200", description = "Batch approved successfully"),
//            @ApiResponse(responseCode = "400", description = "Invalid request or batch not pending"),
//            @ApiResponse(responseCode = "401", description = "Authentication failed"),
//            @ApiResponse(responseCode = "404", description = "Batch not found"),
//            @ApiResponse(responseCode = "500", description = "Internal server error")
//    })
//    public ResponseEntity<ApprovalBatchDto> approveBatch(
//            @Parameter(description = "Batch ID", required = true) @PathVariable Long id,
//            @RequestBody ApprovalRequestDto approvalRequest) {
//        try {
//            if (!"approver123".equals(approvalRequest.getPassword())) {
//                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
//            }
//            Batch batch = batchRepository.findById(id).orElse(null);
//            if (batch == null) return ResponseEntity.notFound().build();
//            if (batch.getPaymentStatus() == null || !batch.getPaymentStatus().equalsIgnoreCase("Pending")) {
//                return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
//            }
//            batch.setPaymentStatus("approved");
//            batch.setLastPaymentDate(java.time.LocalDateTime.now());
//            batchRepository.save(batch);
//            ApprovalBatchDto dto = mapBatchToApprovalDto(batch);
//            dto.setApprovedBy(approvalRequest.getApproverName());
//            dto.setApprovedDate(java.time.LocalDateTime.now());
//            dto.setApprovalComments(approvalRequest.getComments());
//            dto.setStatus("approved");
//            return ResponseEntity.ok(dto);
//        } catch (Exception e) {
//            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
//        }
//    }

    @PutMapping("/{id}/approve")
    @Transactional
    @Operation(summary = "Approve a batch", description = "Approve a pending batch with authentication")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Batch approved successfully"),
            @ApiResponse(responseCode = "400", description = "Invalid request or batch not pending"),
            @ApiResponse(responseCode = "401", description = "Authentication failed"),
            @ApiResponse(responseCode = "404", description = "Batch not found"),
            @ApiResponse(responseCode = "500", description = "Internal server error")
    })
    public ResponseEntity<ApprovalBatchDto> approveBatch(
            @Parameter(description = "Batch ID", required = true) @PathVariable Long id,
            @RequestBody ApprovalRequestDto approvalRequest,
            @RequestHeader(value = "Authorization", required = false) String authHeader) {
        try {
            // Extract user from JWT token
            String currentUserId = null;
            if (authHeader != null && authHeader.startsWith("Bearer ")) {
                String token = authHeader.substring(7);
                if (jwtTokenUtil.validateToken(token)) {
                    currentUserId = jwtTokenUtil.getUsernameFromToken(token);
                }
            }
            
            if (currentUserId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
            }
            
            // Get user and verify password
            User user = userRepository.findByUserId(currentUserId).orElse(null);
            if (user == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
            }
            
            // Verify password
            if (!passwordEncoder.matches(approvalRequest.getPassword(), user.getPassword())) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
            }
            
            Batch batch = batchRepository.findById(id).orElse(null);
            if (batch == null) return ResponseEntity.notFound().build();
            if (batch.getPaymentStatus() == null || !batch.getPaymentStatus().equalsIgnoreCase("Pending")) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
            }

            List<Employee> emps = employeeRepository.findByBatchId(id);
            BigDecimal total=emps.stream()
                    .map(Employee::getSalaryAmount)
                    .filter(Objects::nonNull)
                    .reduce(BigDecimal.ZERO,BigDecimal::add);

            String accNum=batch.getDebitAccount();
            if(accNum==null || accNum.isBlank()){
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);
            }

            BankAccount acct=bankAccountRepository.findByAccountNumber(accNum).orElse(null);
            if(acct==null){
                return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
            }
            if(acct.getBalance().compareTo(total)<0){
                return ResponseEntity.status(HttpStatus.CONFLICT).build();
            }
            acct.setBalance(acct.getBalance().subtract(total));
            bankAccountRepository.save(acct);


            for(Employee e:emps){
                if(e.getPaymentRef() == null || e.getPaymentRef().isBlank()){
                    String token = "TRX-"+ id +"-"+ UUID.randomUUID().toString().replace("-","").substring(0,8).toUpperCase();
                    e.setPaymentRef(token);
                }
            }

            employeeRepository.saveAll(emps);
            batch.setPaymentStatus("approved");
            batch.setLastPaymentDate(java.time.LocalDateTime.now());
            batchRepository.save(batch);
            batchRepository.flush(); // Ensure the status is persisted immediately
            
            // Create approval record
            Approval approval = new Approval();
            approval.setBatchId(id);
            approval.setApprovedBy(currentUserId);
            approval.setStatus("approved");
            approval.setComments(approvalRequest.getComments());
            approval.setApprovedDate(java.time.LocalDateTime.now());
            approvalRepository.save(approval);
            approvalRepository.flush(); // Ensure the approval is persisted immediately
            
            ApprovalBatchDto dto = mapBatchToApprovalDto(batch);
            dto.setApprovedBy(currentUserId);
            dto.setApprovedDate(approval.getApprovedDate());
            dto.setApprovalComments(approvalRequest.getComments());
            dto.setStatus("approved");
            return ResponseEntity.ok(dto);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PutMapping("/{id}/reject")
    @Operation(summary = "Reject a batch", description = "Reject a pending batch with authentication")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Batch rejected successfully"),
            @ApiResponse(responseCode = "400", description = "Invalid request or batch not pending"),
            @ApiResponse(responseCode = "401", description = "Authentication failed"),
            @ApiResponse(responseCode = "404", description = "Batch not found"),
            @ApiResponse(responseCode = "500", description = "Internal server error")
    })
    public ResponseEntity<ApprovalBatchDto> rejectBatch(
            @Parameter(description = "Batch ID", required = true) @PathVariable Long id,
            @RequestBody ApprovalRequestDto approvalRequest,
            @RequestHeader(value = "Authorization", required = false) String authHeader) {
        try {
            // Extract user from JWT token
            String currentUserId = null;
            if (authHeader != null && authHeader.startsWith("Bearer ")) {
                String token = authHeader.substring(7);
                if (jwtTokenUtil.validateToken(token)) {
                    currentUserId = jwtTokenUtil.getUsernameFromToken(token);
                }
            }
            
            if (currentUserId == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
            }
            
            // Get user and verify password
            User user = userRepository.findByUserId(currentUserId).orElse(null);
            if (user == null) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
            }
            
            // Verify password
            if (!passwordEncoder.matches(approvalRequest.getPassword(), user.getPassword())) {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
            }
            
            Batch batch = batchRepository.findById(id).orElse(null);
            if (batch == null) return ResponseEntity.notFound().build();
            if (batch.getPaymentStatus() == null || !batch.getPaymentStatus().equalsIgnoreCase("Pending")) {
                return ResponseEntity.status(HttpStatus.BAD_REQUEST).build();
            }
            batch.setPaymentStatus("rejected");
            batch.setLastPaymentDate(java.time.LocalDateTime.now());
            batchRepository.save(batch);
            batchRepository.flush(); // Ensure the status is persisted immediately
            
            // Create approval record
            Approval approval = new Approval();
            approval.setBatchId(id);
            approval.setApprovedBy(currentUserId);
            approval.setStatus("rejected");
            approval.setComments(approvalRequest.getComments());
            approval.setApprovedDate(java.time.LocalDateTime.now());
            approvalRepository.save(approval);
            approvalRepository.flush(); // Ensure the approval is persisted immediately
            
            ApprovalBatchDto dto = mapBatchToApprovalDto(batch);
            dto.setApprovedBy(currentUserId);
            dto.setApprovedDate(approval.getApprovedDate());
            dto.setApprovalComments(approvalRequest.getComments());
            dto.setStatus("rejected");
            return ResponseEntity.ok(dto);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    private ApprovalBatchDto mapBatchToApprovalDto(Batch batch) {
        java.util.List<Employee> emps = employeeRepository.findByBatchId(batch.getId());
        java.math.BigDecimal total = emps.stream()
                .map(Employee::getSalaryAmount)
                .filter(java.util.Objects::nonNull)
                .reduce(java.math.BigDecimal.ZERO, java.math.BigDecimal::add);
        ApprovalBatchDto dto = new ApprovalBatchDto();
        dto.setId(batch.getId());
        dto.setBatchName(batch.getName());
        dto.setCreatedBy(batch.getUserId());
        dto.setCreatedDate(java.time.LocalDateTime.now());
        dto.setStatus(batch.getPaymentStatus() != null ? batch.getPaymentStatus().toLowerCase() : "pending");
        dto.setTotalAmount(total);
        dto.setCurrency(batch.getCurrency());
        dto.setEmployeeCount(emps.size());
        dto.setApproversRequired(1);
        dto.setApproversAssigned(1);
        dto.setDebitAccount(batch.getDebitAccount());
        dto.setDescription(null);
        
        // Get approval information from Approval table
        java.util.Optional<Approval> approvalOpt = approvalRepository.findByBatchId(batch.getId());
        if (approvalOpt.isPresent()) {
            Approval approval = approvalOpt.get();
            dto.setApprovedBy(approval.getApprovedBy());
            dto.setApprovedDate(approval.getApprovedDate());
            dto.setApprovalComments(approval.getComments());
        }
        
        return dto;
    }

    @GetMapping("/statistics")
    @Operation(summary = "Get approval statistics", description = "Get statistics about pending and reviewed batches")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Successfully retrieved statistics",
                    content = @Content(schema = @Schema(implementation = ApprovalStatisticsDto.class))),
            @ApiResponse(responseCode = "500", description = "Internal server error")
    })
    public ResponseEntity<ApprovalStatisticsDto> getApprovalStatistics() {
        try {
            ApprovalStatisticsDto statistics = approvalService.getApprovalStatistics();
            return ResponseEntity.ok(statistics);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

}



import React, { useState, useEffect } from 'react';
import PayrollDetailsModal from './PayrollDetailsModal';
import Navbar from '../../common/Navbar';
import ApprovalService from '../../services/ApprovalService';
import { getEmployees } from '../../services/payrollapi';

const ApprovalsPage = () => {
  const [allApprovals, setAllApprovals] = useState([]);
  const [filterStatus, setFilterStatus] = useState('all');
  const [selectedPayroll, setSelectedPayroll] = useState(null);
  const [showDetailsModal, setShowDetailsModal] = useState(false);
  const [allEmployees, setAllEmployees] = useState([]);

  // Load reviewed batches from API
  const loadReviewedBatches = async () => {
    try {
      console.log('Loading reviewed batches...');
      const apiBatches = await ApprovalService.getReviewedBatches();
      console.log('Received batches from API:', apiBatches);
      const transformedBatches = apiBatches.map(ApprovalService.transformBatchData);
      console.log('Transformed batches:', transformedBatches);
      setAllApprovals(transformedBatches);
    } catch (error) {
      console.error('Error loading reviewed batches:', error);
      // Fallback to empty array if API fails
      setAllApprovals([]);
    }
  };

  useEffect(() => {
    loadReviewedBatches();
    (async ()=>{
      try{
        const employees=await getEmployees();
        setAllEmployees(Array.isArray(employees) ? employees : []);
      }
      catch(empErr){
        console.error('Error loading employees: ',empErr);
        setAllEmployees([]);
      }
    })();

    const onUpdated = () => {
      loadReviewedBatches();
    };
    window.addEventListener('approvals:updated', onUpdated);
    return () => {
      window.removeEventListener('approvals:updated', onUpdated);
    };
  }, []);

  // Filter approvals based on selected status
  const filteredApprovals = allApprovals.filter(payroll => {
    if (filterStatus === 'all') return true;
    return payroll.status === filterStatus;
  });

  // Calculate statistics
  const stats = {
    total: allApprovals.length,
    approved: allApprovals.filter(p => p.status === 'approved').length,
    rejected: allApprovals.filter(p => p.status === 'rejected').length
  };

  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    });
  };

  const formatCurrency = (amount, currency) => {
    if (currency === 'INR') {
      return new Intl.NumberFormat('en-IN', {
        style: 'currency',
        currency: 'INR'
      }).format(amount);
    } else {
      return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD'
      }).format(amount);
    }
  };

  const handleViewDetails = (payroll) => {
    setSelectedPayroll(payroll);
    setShowDetailsModal(true);
  };

  const handleCloseModal = () => {
    setShowDetailsModal(false);
    setSelectedPayroll(null);
  };

  return (
    <div>
      <Navbar />
    <div className="approvals-page">
      <div className="container">
        {/* Header */}
        <div className="page-header">
          <div className="header-content">
            <div className="header-text">
              <h1 className="page-title">Reviewed Batches</h1>
              <p className="page-subtitle">
                View and manage your reviewed payroll batches
              </p>
            </div>
            <button 
              className="btn btn-outline"
              onClick={loadReviewedBatches}
              style={{ marginTop: '8px' }}
            >
              üîÑ Refresh
            </button>
          </div>
        </div>

        {/* Statistics */}
        <div className="stats-section">
          <div className="stat-card">
            <div className="stat-icon total"></div>
            <div className="stat-content">
              <div className="stat-value">{stats.total}</div>
              <div className="stat-label">Total Reviewed</div>
            </div>
          </div>
          <div className="stat-card">
            <div className="stat-icon approved"></div>
            <div className="stat-content">
              <div className="stat-value">{stats.approved}</div>
              <div className="stat-label">Approved</div>
            </div>
          </div>
          <div className="stat-card">
            <div className="stat-icon rejected"></div>
            <div className="stat-content">
              <div className="stat-value">{stats.rejected}</div>
              <div className="stat-label">Rejected</div>
            </div>
          </div>
        </div>

        {/* Filter */}
        <div className="filter-section">
          <div className="filter-buttons">
            <button 
              className={`filter-btn ${filterStatus === 'all' ? 'active' : ''}`}
              onClick={() => setFilterStatus('all')}
            >
              All ({stats.total})
            </button>
            <button 
              className={`filter-btn ${filterStatus === 'approved' ? 'active' : ''}`}
              onClick={() => setFilterStatus('approved')}
            >
              Approved ({stats.approved})
            </button>
            <button 
              className={`filter-btn ${filterStatus === 'rejected' ? 'active' : ''}`}
              onClick={() => setFilterStatus('rejected')}
            >
              Rejected ({stats.rejected})
            </button>
          </div>
        </div>

        {/* Approvals List */}
        <div className="approvals-section">
          {filteredApprovals.length === 0 ? (
            <div className="empty-state">
              <div className="empty-icon"></div>
              <h3>No approvals found</h3>
              <p>
                {allApprovals.length === 0 
                  ? "You haven't reviewed any payroll batches yet. Go to the main dashboard to review pending batches."
                  : "No payroll batches match the selected filter."
                }
              </p>
            </div>
          ) : (
            <div className="approvals-grid">
              {filteredApprovals.map(payroll => (
                <div key={payroll.id} className="approval-card">
                  <div className="approval-card-header">
                    <div className="approval-card-title">
                      <h3>{payroll.batchName}</h3>
                      <div className={`status-badge status-${payroll.status}`}>
                        {payroll.status === 'approved' ? '‚úÖ' : '‚ùå'} 
                        {payroll.status.toUpperCase()}
                      </div>
                    </div>
                    <div className="approval-card-amount">
                      {formatCurrency(payroll.totalAmount, payroll.currency)}
                    </div>
                  </div>

                  <div className="approval-card-body">
                    <div className="approval-details">
                      <div className="approval-detail">
                        <span className="detail-label">Employees</span>
                        <span className="detail-value">{payroll.employeeCount}</span>
                      </div>
                      <div className="approval-detail">
                        <span className="detail-label">Debit Account</span>
                        <span className="detail-value">{payroll.debitAccount || 'N/A'}</span>
                      </div>
                      <div className="approval-detail">
                        <span className="detail-label">Created By</span>
                        <span className="detail-value">{payroll.createdBy}</span>
                      </div>
                      <div className="approval-detail">
                        <span className="detail-label">Created</span>
                        <span className="detail-value">{formatDate(payroll.createdDate)}</span>
                      </div>
                      <div className="approval-detail">
                        <span className="detail-label">
                          {payroll.status === 'approved' ? 'Approved' : 'Rejected'}
                        </span>
                        <span className="detail-value">{payroll.approvedDate ? formatDate(payroll.approvedDate) : '‚Äî'}</span>
                      </div>
                      {payroll.approvedBy && (
                        <div className="approval-detail">
                          <span className="detail-label">Approved By</span>
                          <span className="detail-value">{payroll.approvedBy}</span>
                        </div>
                      )}
                      {payroll.approvalComments && (
                        <div className="approval-detail">
                          <span className="detail-label">Comments</span>
                          <span className="detail-value">{payroll.approvalComments}</span>
                        </div>
                      )}
                    </div>

                    {payroll.description && (
                      <div className="approval-description">
                        <p>{payroll.description}</p>
                      </div>
                    )}
                  </div>

                  <div className="approval-card-footer">
                    <button 
                      className="btn btn-primary"
                      onClick={() => handleViewDetails(payroll)}
                    >
                      View Details
                    </button>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* Details Modal */}
        {showDetailsModal && (
          <PayrollDetailsModal
            payroll={selectedPayroll}
            employees={allEmployees.filter(
              (e)=>String(e.batchId || ' ') === String(selectedPayroll.id || '')
            )}
            onClose={handleCloseModal}
            onApprove={() => {}} // No approve action for completed approvals
            onReject={() => {}} // No reject action for completed approvals
            isLoading={false}
            showActionButtons={false}
          />
        )}
      </div>
    </div>
    </div>
  );
};

export default ApprovalsPage;
